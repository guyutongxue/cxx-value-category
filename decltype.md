# 引用类型的表达式？

一些奇奇怪怪的文章可能会说出“右值引用类型的表达式”“这个表达式是引用类型的”之类的论断。我们在这一篇为这些流言蜚语做一个了断。

请记住这个重要结论：**表达式绝不可能是引用类型**，只有声明变量时才会有引用类型的参与。

```cpp
int a;       // a 是 int 类型变量
int& b = a;  // b 是 int& 类型变量
int&& c = 1; // c 是 int&& 类型变量

// 但是，表达式类型不可能是引用：
a; // 表达式 a 是 int 类型
b; // 表达式 b 也是 int 类型
c; // 表达式 c 还是 int 类型
```

那么为什么我们总是会遇到“引用类型的表达式”的误解呢？原因在于 `decltype`——我们都知道它可以获取表达式的类型，但这并不完整；`decltype` 可以**同时**获取表达式的两个固有属性：类型和值类别。

这里只考虑 `decltype((x))` 这种双括号的使用场景，单括号的 `decltype` 另有含义。对于表达式 `e`，`decltype((e))` 会得到一个类型：

- `T  `，若 `e` 具有 `T` 类型和纯右值的值类别；
- `T& `，若 `e` 具有 `T` 类型和左值的值类别；
- `T&&`，若 `e` 具有 `T` 类型和亡值的值类别。

所以，`decltype` 返回的类型分为两个部分，去除引用说明符的部分是表达式的类型（恰好表达式的类型不可能是引用类型），然后引用说明符的部分就用来指明表达式的值类别。用引用类型来指代值类别是 C++ 语法中常见的一个……呃……无奈之举，因为 C++ 在代码上没有能明确体现值类别的语法。所以这个抽象的对应关系：

| 引用说明符 | 值类别 |
| ---------- | ------ |
| 无         | 纯右值 |
| `&`        | 左值   |
| `&&`       | 亡值   |

……在很多地方都有体现。比如，函数返回值类型和其调用表达式的值类别：

| 函数返回值类型 | 该函数调用表达式的值类别 |
| -------------- | ------------------------ |
| `T`            | 纯右值                   |
| `T&`           | 左值                     |
| `T&&`          | 亡值                     |

我们知道，函数返回的是不是引用类型会导致语义差异，但返回引用时具体返回左值引用还是右值引用，并没有语义区别，这里就是强行规定来表明这个函数的调用表达式的值类别。

又比如，类型转换运算符中，若操作数 `e` 作为表达式具有 `T` 类型，则

| 表达式                | 含义       | 此表达式的值类别 |
| --------------------- | ---------- | ---------------- |
| `static_cast<T>(e)`   | （见注释） | 纯右值           |
| `static_cast<T&>(e)`  | 无操作     | 左值             |
| `static_cast<T&&>(e)` | 无操作     | 亡值             |

故可以从 `e` 转换出对应值类别的表达式。

此外，在模板类型推导、成员函数引用限定符、结构化绑定引用说明符，都或多或少按照这种方式规定了相关的行为。

## 注释

- `static_cast<T>(e)` 语义如同构造 `T temp(e);` 并返回纯右值类型的 `temp`。……如果 `e` 是纯右值，同样会发生复制消除。
- `e` 是 `T` 类型的表达式时，`static_cast<T&>(e)` 没啥意义。`e` 只能是左值，左值到左值的转换就是如蜜传如蜜。`e` 不能是右值，因为禁止将右值转换为左值：你不能将一个短生命周期的对象转换为长生命周期的对象；延长生命周期只能靠绑定到引用。
